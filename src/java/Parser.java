 /**
   * file: Parser.java
   * author: Artur Barbosa
   * course: CMPT 432
   * assignment: project 3 parser 
   * due date: 4/3/2018
   * 
   * 
   * This file contains the parcer for project 3.
   *
   */
import java.util.ArrayList;
import java.util.List;
import java.util.Stack;


/**
 * This class implements the parser of the grammar that takes a list of Token
 * objects generated by the Lexer, from input source program, and then validates the program
 * as per grammar.
 *
 */
public class Parser {

	private List<Token> tokens;
	private boolean debug;
	private static int progNum = 1;
	
	private String cst = "";
	private boolean parseError = false;
	private boolean warning = false;
	private int nextTokenIndex;
	Stack<Integer> cstIdentValues = new Stack<Integer>();
	
	/**
	 * Class constructor that creates a new Parser for a given set of Token objects
	 * 
	 * @param tokens a List of Token objects 
	 * @param debug boolean flag whether to print debug message to console
	 */
	public Parser(List<Token> tokens, boolean debug){
		this.tokens = tokens;
		this.debug = debug;
		cst = "";
		parseError = false;
		nextTokenIndex = 0;
	}
	
	/**
	 * Remove and return the next token from the input list of tokens.
	 * 
	 * @return the next Token object
	 */
	private Token getNextToken(){
		if(nextTokenIndex >= tokens.size()) return null;
		return tokens.get(nextTokenIndex++);
	}
	
	/**
	 * Get the next token from input list of tokens without removing it.
	 * 
	 * @return the next Token object
	 */
	private Token peekNextToken(){
		if(nextTokenIndex >= tokens.size()) return null;
		return tokens.get(nextTokenIndex);
	}
	
	/**
	 * Append CST header with current indentation to the CST
	 * 
	 * @param header the given header string
	 */
	private void appendCSTHeader(String header, int indentation) {		
		for(int i=0; i < indentation; i++) cst += "-";
		cst += header + "\n";
	} 
	
	/**
	 * Parse to validate the list of Token lexed by Lexer
	 */
	public AST parse(){
		if(debug){
			System.out.println("PARSER: parse()");
		}		
		AST ast = parseProgram();
		progNum++;
		return ast;
	}
	
	private AST parseProgram(){
		if(debug) System.out.println("PARSER: parseProgram()");
		cst += "<Program>\n";
		cstIdentValues.push(1);
		AST ast = parseBlock();
		if(parseError) return null;
		Token t = getNextToken();
		if(t == null){
			warning = true;
			return null;
		}
		if(t.getType() != Token.Type.EOP){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [EOP] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		cst += "-[$]";
		return ast;
	}
	
	private Block parseBlock(){
		if(debug) System.out.println("PARSER: parseBlock()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Block>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.LBRACE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_OPENING_BRACE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("[{]", indentation+1);
		
		cstIdentValues.push(indentation+1);
		List<Statement> statements = parseStatementList();
		if(parseError) return null;
		t = getNextToken();
		if(t.getType() != Token.Type.RBRACE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_CLOSING_BRACE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("[}]", indentation+1);
		cstIdentValues.pop();
		Block block = new Block();
		for(Statement stmt : statements)
			block.addStatement(stmt);
		return block;
	}
	
	private List<Statement> parseStatementList(){
		List<Statement> statements = new ArrayList<Statement>();
		if(debug) System.out.println("PARSER: parseStatementList()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Statemment List>", indentation);
		Token t = peekNextToken();
		
		while(t.getType() == Token.Type.PRINT || t.getType() == Token.Type.ID
				|| t.getType() == Token.Type.TYPE || t.getType() == Token.Type.WHILE
				|| t.getType() == Token.Type.IF || t.getType() == Token.Type.LBRACE){
			cstIdentValues.push(indentation+1);
			Statement stmt = parseStatement();
			if(parseError) return null;
			if(stmt == null) return null;
			statements.add(stmt);
			t = peekNextToken();
		}		
		cstIdentValues.pop();
		return statements;
	}
	
	private Statement parseStatement(){
		if(debug) System.out.println("PARSER: parseStatement()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Statement>", indentation);
		Token t = peekNextToken();
		cstIdentValues.push(indentation+1);
		Statement stmt = null;
		switch(t.getType()){
		case PRINT:
			stmt = parsePrintStatement();
			break;
		case ID:
			//parseId();
			stmt = parseAssignmentStatement();
			break;
		case TYPE:
			//parseType();
			stmt = parseVarDecl();
			break;
		case WHILE:
			stmt = parseWhileStatement();
			break;
		case IF:
			stmt = parseIfStatement();
			break;
		case LBRACE:
			stmt = parseBlock();
			break;
		}
		cstIdentValues.pop();
		return stmt;
	}
	
	private Statement parsePrintStatement(){
		if(debug) System.out.println("PARSER: parsePrintStatement()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<PrintStatement>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.PRINT){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_PRINT] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		t = getNextToken();
		if(t.getType() != Token.Type.LPAREN){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_OPENING_PARENTHESIS] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.push(indentation+1);
		Expr expr = parseExpr();
		if(parseError) return null;
		t = getNextToken();
		if(t.getType() != Token.Type.RPAREN){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_CLOSING_PARENTHESIS] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.pop();
		return new PrintStatement(expr);
	}
	
	private Statement parseAssignmentStatement(){
		if(debug) System.out.println("PARSER: parseAssignmentStatement()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<AssignmentStatement>", indentation);
		cstIdentValues.push(indentation+1);
		Id id = parseId();
		if(parseError) return null;
		Token t = getNextToken();
		if(t.getType() != Token.Type.ASSIGN){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_ASSIGNMENT] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.push(indentation+1);
		Expr expr = parseExpr();
		return new AssignmentStatement(id.getToken(), expr);
	}
	
	private Statement parseVarDecl(){
		if(debug) System.out.println("PARSER: parseVarDecl()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Type>", indentation);
		cstIdentValues.push(indentation+1);
		Token type = parseType();
		if(parseError) return null;
		Id id = parseId();	
		return new VariableDeclaration(type, id.getToken());
	}
	
	private Statement parseWhileStatement(){
		if(debug) System.out.println("PARSER: parseWhileStatement()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<WhileStatement>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.WHILE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_WHILE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		BooleanExpr boolExpr = parseBooleanExpr();
		if(parseError) return null;
		Block block = parseBlock();
		return new WhileStatement(boolExpr, block);
	}
	
	private Statement parseIfStatement(){
		if(debug) System.out.println("PARSER: parseIfStatement()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<IfStatement>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.IF){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_IF] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		BooleanExpr boolExpr = parseBooleanExpr();
		if(parseError) return null;
		Block block = parseBlock();
		return new WhileStatement(boolExpr, block);
	}
	
	private Expr parseExpr(){
		if(debug) System.out.println("PARSER: parseExpr()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Expr>", indentation);
		Token t = peekNextToken();
		Expr expr = null;
		if(t.getType() == Token.Type.DIGIT){
			cstIdentValues.push(indentation+1);
			expr = parseIntExpr();
			if(parseError) return null;
		}
		else if(t.getType() == Token.Type.QUOTE){
			cstIdentValues.push(indentation+1);
			expr = parseStringExpr();
			if(parseError) return null;
		}
		else if(t.getType() == Token.Type.LPAREN || t.getType() == Token.Type.BOOL_TRUE || t.getType() == Token.Type.BOOL_FALSE){
			cstIdentValues.push(indentation+1);
			expr = parseBooleanExpr();
			if(parseError) return null;
		}
		else if(t.getType() == Token.Type.ID){
			cstIdentValues.push(indentation+1);
			expr = parseId();
			if(parseError) return null;
		}
		else{
			if(debug){
				System.out.println("PARSER: ERROR: Expected Expr Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		cstIdentValues.pop();
		return expr;
	}
	
	private IntExpr parseIntExpr(){
		if(debug) System.out.println("PARSER: parseIntExpr()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<IntExpr>", indentation);
		cstIdentValues.push(indentation+1);
		IntExpr digit = parseDigit();
		if(parseError) return null;
		Token t = peekNextToken();
		IntExpr intExpr = digit;
		if(t.getType() == Token.Type.PLUS){
			cstIdentValues.push(indentation+1);
			parseIntOp();
			if(parseError) return null;
			cstIdentValues.push(indentation+1);
			IntExpr expr = (IntExpr)parseExpr();
			if(parseError) return null;
			intExpr = new AddExpr(digit, expr);
		}
		cstIdentValues.pop();
		return intExpr;
	}
	
	private StringExpr parseStringExpr(){
		if(debug) System.out.println("PARSER: parseStringExpr()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<StringExpr>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.QUOTE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_QUOTE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("[\"]", indentation+1);
		cstIdentValues.push(indentation+1);
		String str = parseCharList();
		if(parseError) return null;
		t = getNextToken();
		if(t.getType() != Token.Type.QUOTE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_QUOTE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("[\"]", indentation+1);
		cstIdentValues.pop();
		return new StringExpr(str);
	}
	
	private BooleanExpr parseBooleanExpr(){
		Token t = peekNextToken();
		if(debug) System.out.println("PARSER: parseBooleanExpr() ");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<BooleanExpr>", indentation);
		//Token t = peekNextToken();
		BooleanExpr expr1;
		BooleanExpr expr2;
		Token boolOp;
		if(t.getType() != Token.Type.LPAREN && t.getType() != Token.Type.BOOL_TRUE && t.getType() != Token.Type.BOOL_FALSE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_OPENING_PARENTHESIS/T_BOOLEAN_VALUE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		if(t.getType() == Token.Type.LPAREN) {
			getNextToken();
			appendCSTHeader("[(]", indentation+1);
			cstIdentValues.push(indentation+1);
			expr1 = (BooleanExpr)parseExpr();
			if(parseError) return null;
			cstIdentValues.push(indentation+1);
			boolOp = parseBoolOp();
			if(parseError) return null;
			cstIdentValues.push(indentation+1);
			expr2 = (BooleanExpr)parseExpr();
			if(parseError) return null;
			t = getNextToken();
			if(t.getType() != Token.Type.RPAREN){
				if(debug){
					System.out.println("PARSER: ERROR: Expected [T_CLOSING_PARENTHESIS] Got " + t.toString());
				}
				parseError = true;
				return null;
			}
			appendCSTHeader("[)]", indentation+1);
			cstIdentValues.pop();
			return new BooleanOp(expr1, expr2, boolOp);
		}else {
			return parseBoolVal();
		}
		
	}
	
	private Id parseId(){
		if(debug) System.out.println("PARSER: parseId()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Id>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.ID){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_VARIABLE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.pop();
		return new Id(t);
	}
	
	private String parseCharList(){
		String str = "";
		
		if(debug) System.out.println("PARSER: parseCharList()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<CharList>", indentation);
		Token t = peekNextToken();
		if(t.getType() == Token.Type.CHAR){
			cstIdentValues.push(indentation+1);
			parseChar();
			str += t.getLexeme();
			if(parseError) return null;
			cstIdentValues.push(indentation+1);
			str += parseCharList();
			if(parseError) return null;
		}
		cstIdentValues.pop();
		return str;
	}
	
	private Token parseType(){
		if(debug) System.out.println("PARSER: parseType()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Type>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.TYPE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_TYPE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.pop();
		return t;
	}
	
	private Token parseChar(){
		if(debug) System.out.println("PARSER: parseChar()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Char>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.CHAR){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_CHAR] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.pop();
		return t;
	}
	
	private void parseSpace(){
		if(debug) System.out.println("PARSER: parseSpace()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Space>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.CHAR || t.getLexeme().equals(" ")){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_SPACE] Got " + t.toString());
			}
			parseError = true;
			return;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.pop();
	}
	
	private IntExpr parseDigit(){
		if(debug) System.out.println("PARSER: parseDigit()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<Digit>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.DIGIT){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_DIGIT] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("["+t.getLexeme()+"]", indentation+1);
		cstIdentValues.pop();
		return new Digit(t);
	}
	
	private BooleanExpr parseBoolVal() {
		if(debug) System.out.println("PARSER: parseBoolVal()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<BooleanVal>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.BOOL_FALSE && t.getType() != Token.Type.BOOL_TRUE){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_BOOLEAN_VALUE] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		if(t.getType() == Token.Type.BOOL_TRUE){
			appendCSTHeader("[true]", indentation+1);
		}
		else{
			appendCSTHeader("[false]", indentation+1);
		}
		cstIdentValues.pop();
		return new BooleanValue(t);
	}
	
	private Token parseBoolOp(){
		if(debug) System.out.println("PARSER: parseBoolOp()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<BooleanOp>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.BOOLOP_EQUAL && t.getType() != Token.Type.BOOLOP_NOT_EQUAL){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_BOOL_OP] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		if(t.getType() == Token.Type.BOOLOP_EQUAL){
			appendCSTHeader("[==]", indentation+1);
		}
		else{
			appendCSTHeader("[!=]", indentation+1);
		}
		cstIdentValues.pop();
		return t;
	}
	
	private Token parseIntOp(){
		if(debug) System.out.println("PARSER: parseIntOp()");
		int indentation = cstIdentValues.peek();
		appendCSTHeader("<IntOp>", indentation);
		Token t = getNextToken();
		if(t.getType() != Token.Type.PLUS){
			if(debug){
				System.out.println("PARSER: ERROR: Expected [T_INT_OP] Got " + t.toString());
			}
			parseError = true;
			return null;
		}
		appendCSTHeader("[+]", indentation+1);
		cstIdentValues.pop();
		return t;
	}
	
	/**
	 * Get the generated CST (concrete syntax tree) generated during
	 * the parsing process.
	 * 
	 * @return the string of the generated CST
	 */
	public String getCST(){
		return cst;
	}
	
	/**
	 * Check to see whether there was parse error.
	 * 
	 * @return true if there is no parse error, otherwise false
	 */
	public boolean isParseOk(){
		return !parseError;
	}
}




